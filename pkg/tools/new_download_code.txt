func (p *DownloadedTool) downloadTool() error {
// 开始/恢复下载前清除暂停标记
atomic.StoreInt32(&p.paused, 0)
p.ensureMetadata()
// 已存在直接完成
if p.DoesToolExist() {
p.resetDownloadProcess(true)
p.emitProgress(DownloadProgress{Status: "completed"})
return nil
}

toolFolder := p.GetWritableToolFolder()
if _, statErr := os.Stat(toolFolder); os.IsNotExist(statErr) {
if mkErr := os.MkdirAll(toolFolder, 0755); mkErr != nil {
p.emitProgress(DownloadProgress{Status: "failed", Error: mkErr})
return mkErr
}
}
// 清理残留的临时解压目录
tmpExtractFolder := filepath.Join(filepath.Dir(toolFolder), ".tmp_"+filepath.Base(toolFolder))
if _, dirErr := os.Stat(tmpExtractFolder); dirErr == nil {
if rmErr := os.RemoveAll(tmpExtractFolder); rmErr != nil {
return fmt.Errorf("failed to remove temporary extraction folder: %w", rmErr)
}
}

urls := p.getDownloadUrls()
if len(urls) == 0 {
e := errors.New("no download urls provided")
p.emitProgress(DownloadProgress{Status: "failed", Error: e})
return e
}

failedList := make([]string, 0)
totalAttempts := len(urls)

var lastErr error
for i, u := range urls {
if u == "" {
continue
}
// 每次尝试前，主动广播一条"切换/开始尝试"消息到 UI（trying 状态）
p.emitProgress(DownloadProgress{Status: "trying", AttemptIndex: i + 1, TotalAttempts: totalAttempts, CurrentURL: u, FailedURLs: append([]string{}, failedList...), AllURLs: append([]string{}, urls...)})
if i > 0 {
log.Printf("[%s@%s] retry with alternative url (%d/%d): %s", p.ToolName, p.Version, i+1, totalAttempts, u)
} else {
log.Printf("[%s@%s] start download with url (%d/%d): %s", p.ToolName, p.Version, i+1, totalAttempts, u)
}
err := p.attemptDownload(u, toolFolder, i, totalAttempts, urls, &failedList)
if err != nil {
if errors.Is(err, ErrDownloadPaused) {
return ErrDownloadPaused
}
lastErr = err
continue
}
// 成功
return nil
}
if lastErr != nil {
p.emitProgress(DownloadProgress{Status: "failed", Error: lastErr, AttemptIndex: totalAttempts, TotalAttempts: totalAttempts, FailedURLs: append([]string{}, failedList...), AllURLs: append([]string{}, urls...)})
return lastErr
}
return errors.New("unexpected download failure without error")
}

// attemptDownload 尝试从单个 URL 下载工具，返回 nil 表示成功
func (p *DownloadedTool) attemptDownload(url, toolFolder string, idx, totalAttempts int, allURLs []string, failedList *[]string) error {
// 先发送 HEAD 请求获取文件元信息
var downloadFileName string
var knownTotalBytes int64
if headInfo, herr := getHeadInfo(url); herr == nil {
if headInfo.FileName != "" {
downloadFileName = headInfo.FileName
}
knownTotalBytes = headInfo.ContentLength
}
// 若 HEAD 请求未能获取文件名，回退到从 URL 路径推测
if downloadFileName == "" {
name, err := getFileNameFromURL(url)
if err != nil {
return err
}
downloadFileName = name
}
tmpPath := filepath.Join(toolFolder, downloadFileName)

// 记录本地已存在大小用于断点续传
var existingSize int64
if stat, statErr := os.Stat(tmpPath); statErr == nil {
existingSize = stat.Size()
}

// 根据 HEAD 信息和本地文件状态决定下载策略
needDownload, deleteFirst, err := p.shouldDownload(knownTotalBytes, existingSize, tmpPath, url)
if err != nil {
*failedList = append(*failedList, url)
return err
}

// 如果需要删除损坏的本地文件
if deleteFirst {
if err := os.Remove(tmpPath); err != nil && !os.IsNotExist(err) {
*failedList = append(*failedList, url)
return fmt.Errorf("failed to remove corrupted file: %w", err)
}
existingSize = 0 // 重置已存在大小
}

if needDownload {
if err := p.performDownload(url, tmpPath, existingSize, knownTotalBytes, idx, totalAttempts, allURLs, failedList); err != nil {
return err
}
}

// 解压阶段
return p.extractIfNeeded(downloadFileName, tmpPath, toolFolder, url, idx, totalAttempts, allURLs, failedList)
}

// shouldDownload 检查是否需要下载，返回 (needDownload, deleteFirst, error)
// needDownload: 是否需要执行下载
// deleteFirst: 是否需要先删除本地文件（文件损坏的情况）
func (p *DownloadedTool) shouldDownload(knownTotalBytes, existingSize int64, tmpPath, url string) (bool, bool, error) {
// 情况1：本地文件不存在，需要下载
if existingSize == 0 {
return true, false, nil
}

// 情况2：HEAD 未返回文件大小，无法判断，继续下载（断点续传）
if knownTotalBytes == 0 {
return true, false, nil
}

// 情况3：本地文件大小等于服务器文件大小，已完整下载
if existingSize == knownTotalBytes {
log.Printf("[%s@%s] file already complete (%d bytes), skip download", p.ToolName, p.Version, existingSize)
return false, false, nil
}

// 情况4：本地文件大小大于服务器文件大小，文件损坏或服务器文件已变更
if existingSize > knownTotalBytes {
log.Printf("[%s@%s] local file (%d bytes) larger than server (%d bytes), will delete and re-download", p.ToolName, p.Version, existingSize, knownTotalBytes)
return true, true, nil // 需要先删除再下载
}

// 情况5：本地文件小于服务器文件，断点续传
return true, false, nil
}

// performDownload 执行实际的下载操作
func (p *DownloadedTool) performDownload(url, tmpPath string, existingSize, knownTotalBytes int64, idx, totalAttempts int, allURLs []string, failedList *[]string) error {
req, err := http.NewRequest("GET", url, nil)
if err != nil {
return err
}
if existingSize > 0 {
req.Header.Set("Range", fmt.Sprintf("bytes=%d-", existingSize))
}

client := &http.Client{}
resp, err := client.Do(req)
if err != nil {
*failedList = append(*failedList, url)
log.Printf("[%s@%s] attempt %d/%d failed to start: %v, url=%s", p.ToolName, p.Version, idx+1, totalAttempts, err, url)
return err
}
defer resp.Body.Close()

// 处理 416 Range Not Satisfiable（理论上在 shouldDownload 已处理，但作为防御性编程）
if resp.StatusCode == http.StatusRequestedRangeNotSatisfiable {
if knownTotalBytes > 0 && existingSize == knownTotalBytes {
// 文件已完整，跳过下载
return nil
}
err := fmt.Errorf("range request failed (416) for %s, local=%d, server=%d", url, existingSize, knownTotalBytes)
*failedList = append(*failedList, url)
return err
}

if resp.StatusCode != http.StatusOK && resp.StatusCode != http.StatusPartialContent {
err := fmt.Errorf("failed to download tool %s: %s, url: %s", p.ToolName, resp.Status, url)
*failedList = append(*failedList, url)
log.Printf("[%s@%s] attempt %d/%d response error: %v", p.ToolName, p.Version, idx+1, totalAttempts, err)
return err
}

// 打开文件写入
var out *os.File
if resp.StatusCode == http.StatusPartialContent && existingSize > 0 {
out, err = os.OpenFile(tmpPath, os.O_WRONLY|os.O_APPEND, 0644)
} else {
out, err = os.Create(tmpPath)
existingSize = 0 // 重新下载，清零已存在大小
}
if err != nil {
return err
}

// 计算总大小：优先使用 HEAD 请求获取的大小
totalBytes := knownTotalBytes
if totalBytes == 0 {
totalBytes = resp.ContentLength
if resp.StatusCode == http.StatusPartialContent && existingSize > 0 {
totalBytes += existingSize
}
}

// 可选限速（仅用于测试 UI）：通过环境变量 REMOTETOOLS_DOWNLOAD_LIMIT_BPS 启用
limitedBody := newRateLimitedReader(resp.Body, getDownloadLimitBPS())
pr := &progressReader{
reader:          limitedBody,
totalBytes:      totalBytes,
downloadedBytes: existingSize,
lastUpdate:      time.Now(),
lastBytes:       existingSize,
callback:        p.emitProgress,
pausedFlag:      &p.paused,
attemptIndex:    idx + 1,
totalAttempts:   totalAttempts,
currentURL:      url,
failedPtr:       failedList,
allURLs:         allURLs,
}

if _, err = io.Copy(out, pr); err != nil {
_ = out.Close()
if errors.Is(err, ErrDownloadPaused) {
var currentSize int64
if stat, sErr := os.Stat(tmpPath); sErr == nil {
currentSize = stat.Size()
}
p.emitProgress(DownloadProgress{
TotalBytes: totalBytes, DownloadedBytes: currentSize, Speed: 0, Status: "paused",
AttemptIndex: idx + 1, TotalAttempts: totalAttempts, CurrentURL: url,
FailedURLs: append([]string{}, *failedList...), AllURLs: append([]string{}, allURLs...),
})
return ErrDownloadPaused
}
*failedList = append(*failedList, url)
log.Printf("[%s@%s] attempt %d/%d streaming error: %v", p.ToolName, p.Version, idx+1, totalAttempts, err)
return err
}

if cerr := out.Close(); cerr != nil {
return cerr
}
return nil
}

// extractIfNeeded 根据文件后缀解压文件
func (p *DownloadedTool) extractIfNeeded(downloadFileName, tmpPath, toolFolder, url string, idx, totalAttempts int, allURLs []string, failedList *[]string) error {
if strings.HasSuffix(downloadFileName, ".zip") || strings.HasSuffix(downloadFileName, ".tar.gz") || strings.HasSuffix(downloadFileName, ".tar.xz") {
p.emitProgress(DownloadProgress{
Status: "extracting", AttemptIndex: idx + 1, TotalAttempts: totalAttempts, CurrentURL: url,
FailedURLs: append([]string{}, *failedList...), AllURLs: append([]string{}, allURLs...),
})
if err := extractDownloadedFile(tmpPath, toolFolder); err != nil {
*failedList = append(*failedList, url)
return err
}
// 删除压缩包
_ = os.Remove(tmpPath)
}
// 非压缩文件直接视为完成
return nil
}

